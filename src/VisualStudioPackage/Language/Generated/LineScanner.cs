//
//  This CSharp output file generated by Gardens Point LEX
//  Version:  0.5.1.121 (2007-03-11)
//  Machine:  PUTER
//  DateTime: 20/03/2007 7:44:06 AM
//  UserName: Wayne
//  GPLEX input file <LineScanner.lex>
//  GPLEX frame file <D:\gppg-gplex\gppg-gplex\gplexx.frame>
//
//  Option settings: noverbose, parser, nostack, nominimize, compress, babel
//

#pragma warning disable 0162

#define BACKUP
#define LEFTANCHORS
#define BABEL
//
// gplexx.frame
// Version 0.5.1 of 11 March 2007
// Derived from gplex.frame version of 2-September-2006. 
// Left and Right Anchored state support.
// Start condition stack. Two generic params.
// Using fixed length context handling for right anchors
//
using System;
using System.IO;
using System.Collections.Generic;
#if !STANDALONE
using Ruby.NET.ParserGenerator;
#endif

using Ruby.NET.Parser;

namespace Ruby.NET.Lexer
{   
    /// <summary>
    /// Summary Canonical example of GPLEX automaton
    /// </summary>
    
#if STANDALONE
    //
    // These are the dummy declarations for stand-alone GPLEX applications
    // normally these declarations would come from the parser.
    // If you declare /noparser, or %option noparser then you get this.
    //

    public enum Tokens
    { 
      EOF = 0, maxParseToken = int.MaxValue 
      // must have at least these two, values are almost arbitrary
    }

    public abstract class ScanBase
    {
        public abstract int yylex();
#if BABEL
        protected abstract int CurrentSc { get; set; }
        // EolState is the 32-bit of state data persisted at 
        // the end of each line for Visual Studio colorization.  
        // The default is to return CurrentSc.  You must override
        // this if you want more complicated behavior.
        public virtual int EolState { get { return CurrentSc;} set { CurrentSc = value; } }
    }
    
    public interface IColorScan
    {
        void SetSource(string source, int offset);
        int GetNext(ref int state, out int start, out int end);
#endif // BABEL
    }

#endif // STANDALONE

    public abstract class ScanBuff
    {
        public const char EOF = (char)256;
        public abstract int Pos { get; set; }
        public abstract int Read();
        public abstract int Peek();
        public abstract string GetString(int b, int e);
    }
    
    // If the compiler can't find ScanBase maybe you need to run
    // GPPG with the /gplex option, or GPLEX with /noparser
#if BABEL
    public sealed class Scanner : ScanBase, IColorScan
    {
        public ScanBuff buffer;
        int currentScOrd;  // start condition ordinal
        
        public int CurrentSc 
        {
             // The current start state is a property
             // to try to avoid the user error of setting
             // scState but forgetting to update the FSA
             // start state "currentStart"
             //
             get { return currentScOrd; }  // i.e. return YY_START;
             set { currentScOrd = value;   // i.e. BEGIN(value);
                   currentStart = startState[value]; }
        }
#else  // BABEL
    public sealed class Scanner : ScanBase
    {
        public ScanBuff buffer;
        int currentScOrd;  // start condition ordinal
#endif // BABEL
        
        private static int GetMaxParseToken() {
            System.Reflection.FieldInfo f = typeof(Tokens).GetField("maxParseToken");
            return (f == null ? int.MaxValue : (int)f.GetValue(null));
        }
        
        static int parserMax = GetMaxParseToken();
        
        enum Result {accept, noMatch, contextFound};

        const int maxAccept = 104;
        const int initial = 1;
        const int eofNum = 0;
        const int goStart = -1;
        const int INITIAL = 0;
        const int DEF = 1;
        const int CLASS = 2;

        int state;
        int currentStart = initial;
        int chr;           // last character read
        int cPos;          // position of chr
        int lNum = 0;      // current line number
        int lineStart;     // start of line

        //
        // The following instance variables are used, among other
        // things, for constructing the yylloc location objects.
        //
        int tokPos;        // buffer position at start of token
        int tokCol;        // zero-based column number at start of token
        int tokLin;        // line number at start of token
        int tokEPos;       // buffer position at end of token
        int tokECol;       // column number at end of token
        int tokELin;       // line number at end of token
        string tokTxt;     // lazily constructed text of token
#if STACK          
        private Stack<int> scStack = new Stack<int>();
#endif // STACK

#region ScannerTables
   struct Table {
        public int min; public int rng; public int dflt;
        public sbyte[] nxt;
        public Table(int m, int x, int d, sbyte[] n) {
            min = m; rng = x; dflt = d; nxt = n;
        }
    };

   static int[] startState = {1, 93, 99, 0};

   static int[] anchorState = {2, 93, 99, 0};

    static Table[] NxS = new Table[116];

    static Scanner() {
    NxS[0] = new Table(0, 0, 0, null);
    NxS[1] = new Table(9, 118, 4, new sbyte[] {5, 6, 5, 5, 5, 4, 
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
        4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 
        21, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 25, 26, 27, 28, 
        29, 30, 31, 31, 31, 31, 32, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
        31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 33, 34, 35, 36, 
        37, 38, 31, 31, 39, 40, 32, 31, 31, 31, 31, 31, 31, 31, 41, 31, 
        31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 42, 43, 44, 45});
    NxS[2] = new Table(0, 127, 4, new sbyte[] {3, 4, 4, 4, 4, 4, 
        4, 4, 4, 5, 6, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 7, 8, 9, 10, 11, 
        12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 23, 23, 23, 23, 
        23, 23, 23, 23, 24, 25, 26, 27, 28, 29, 30, 31, 31, 31, 31, 32, 
        31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
        31, 31, 31, 31, 31, 33, 34, 35, 36, 37, 38, 31, 31, 39, 40, 32, 
        31, 31, 31, 31, 31, 31, 31, 41, 31, 31, 31, 31, 31, 31, 31, 31, 
        31, 31, 31, 31, 31, 42, 43, 44, 45});
    NxS[3] = new Table(0, 0, -1, null);
    NxS[4] = new Table(0, 0, -1, null);
    NxS[5] = new Table(9, 24, -1, new sbyte[] {6, 6, 6, 6, 6, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, 6});
    NxS[6] = new Table(9, 24, -1, new sbyte[] {6, 6, 6, 6, 6, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, 6});
    NxS[7] = new Table(0, 0, -1, null);
    NxS[8] = new Table(10, 83, 114, new sbyte[] {-1, 114, 114, 114, 114, 114, 
        114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 
        114, 114, 91, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 
        114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 
        114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 
        114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 115});
    NxS[9] = new Table(10, 1, 90, new sbyte[] {-1});
    NxS[10] = new Table(33, 90, -1, new sbyte[] {83, 83, -1, 83, -1, 84, 
        85, -1, -1, 83, 84, 83, 113, 83, 83, 86, 86, 86, 86, 86, 86, 86, 
        86, 86, 86, 83, 83, 83, 83, 83, 83, 83, 69, 69, 69, 69, 69, 69, 
        69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 
        69, 69, 69, 69, -1, 87, -1, -1, 69, 84, 69, 69, 69, 69, 69, 69, 
        69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 
        69, 69, 69, 69});
    NxS[11] = new Table(0, 0, -1, null);
    NxS[12] = new Table(0, 0, -1, null);
    NxS[13] = new Table(10, 83, 111, new sbyte[] {-1, 111, 111, 111, 111, 111, 
        111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 
        111, 111, 111, 111, 111, 111, 111, 81, 111, 111, 111, 111, 111, 111, 111, 111, 
        111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 
        111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 
        111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 112});
    NxS[14] = new Table(0, 0, -1, null);
    NxS[15] = new Table(0, 0, -1, null);
    NxS[16] = new Table(0, 0, -1, null);
    NxS[17] = new Table(64, 1, -1, new sbyte[] {80});
    NxS[18] = new Table(0, 0, -1, null);
    NxS[19] = new Table(64, 1, -1, new sbyte[] {79});
    NxS[20] = new Table(46, 56, -1, new sbyte[] {78, -1, 66, 66, 66, 66, 
        66, 66, 66, 66, 66, 66, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, 107, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 66, -1, -1, -1, -1, 
        -1, 107});
    NxS[21] = new Table(0, 0, -1, null);
    NxS[22] = new Table(46, 75, -1, new sbyte[] {61, -1, 71, 71, 71, 71, 
        71, 71, 71, 71, 71, 71, -1, -1, -1, -1, -1, -1, -1, -1, 72, -1, 
        109, 108, -1, -1, -1, -1, -1, -1, -1, -1, -1, 110, -1, -1, -1, -1, 
        -1, -1, -1, -1, 73, -1, -1, -1, -1, -1, -1, 71, -1, -1, 72, -1, 
        109, 108, -1, -1, -1, -1, -1, -1, -1, -1, -1, 110, -1, -1, -1, -1, 
        -1, -1, -1, -1, 73});
    NxS[23] = new Table(46, 56, -1, new sbyte[] {61, -1, 71, 71, 71, 71, 
        71, 71, 71, 71, 71, 71, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, 108, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 71, -1, -1, -1, -1, 
        -1, 108});
    NxS[24] = new Table(58, 1, -1, new sbyte[] {70});
    NxS[25] = new Table(0, 0, -1, null);
    NxS[26] = new Table(0, 0, -1, null);
    NxS[27] = new Table(0, 0, -1, null);
    NxS[28] = new Table(0, 0, -1, null);
    NxS[29] = new Table(0, 0, -1, null);
    NxS[30] = new Table(65, 58, -1, new sbyte[] {69, 69, 69, 69, 69, 69, 
        69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 
        69, 69, 69, 69, -1, -1, -1, -1, 69, -1, 69, 69, 69, 69, 69, 69, 
        69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 
        69, 69, 69, 69});
    NxS[31] = new Table(48, 75, -1, new sbyte[] {47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, -1, -1, -1, -1, -1, -1, -1, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, -1, -1, -1, -1, 47, -1, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47});
    NxS[32] = new Table(43, 80, -1, new sbyte[] {64, -1, 64, -1, -1, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, -1, -1, -1, -1, -1, -1, -1, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, -1, -1, -1, -1, 47, -1, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47});
    NxS[33] = new Table(0, 0, -1, null);
    NxS[34] = new Table(0, 0, -1, null);
    NxS[35] = new Table(0, 0, -1, null);
    NxS[36] = new Table(0, 0, -1, null);
    NxS[37] = new Table(46, 77, -1, new sbyte[] {61, -1, 62, 62, 62, 62, 
        62, 62, 62, 62, 62, 62, -1, -1, -1, -1, -1, -1, -1, 47, 47, 47, 
        47, 63, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, -1, -1, -1, -1, 62, -1, 47, 47, 47, 
        47, 63, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47});
    NxS[38] = new Table(10, 87, 105, new sbyte[] {-1, 105, 105, 105, 105, 105, 
        105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 
        105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 
        105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 
        105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 
        105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 106, 105, 105, 105, 
        59});
    NxS[39] = new Table(48, 75, -1, new sbyte[] {47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, -1, -1, -1, -1, -1, -1, -1, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, -1, -1, -1, -1, 47, -1, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 55, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47});
    NxS[40] = new Table(48, 75, -1, new sbyte[] {47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, -1, -1, -1, -1, -1, -1, -1, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, -1, -1, -1, -1, 47, -1, 47, 47, 47, 47, 53, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47});
    NxS[41] = new Table(48, 75, -1, new sbyte[] {47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, -1, -1, -1, -1, -1, -1, -1, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, -1, -1, -1, -1, 47, -1, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 48, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47});
    NxS[42] = new Table(0, 0, -1, null);
    NxS[43] = new Table(124, 1, -1, new sbyte[] {46});
    NxS[44] = new Table(0, 0, -1, null);
    NxS[45] = new Table(0, 0, -1, null);
    NxS[46] = new Table(0, 0, -1, null);
    NxS[47] = new Table(48, 75, -1, new sbyte[] {47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, -1, -1, -1, -1, -1, -1, -1, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, -1, -1, -1, -1, 47, -1, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47});
    NxS[48] = new Table(48, 75, -1, new sbyte[] {47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, -1, -1, -1, -1, -1, -1, -1, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, -1, -1, -1, -1, 47, -1, 47, 47, 47, 49, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47});
    NxS[49] = new Table(48, 75, -1, new sbyte[] {47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, -1, -1, -1, -1, -1, -1, -1, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, -1, -1, -1, -1, 47, -1, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 50, 
        47, 47, 47, 47, 47});
    NxS[50] = new Table(48, 75, -1, new sbyte[] {47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, -1, -1, -1, -1, -1, -1, -1, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, -1, -1, -1, -1, 47, -1, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 51, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47});
    NxS[51] = new Table(48, 75, -1, new sbyte[] {47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, -1, -1, -1, -1, -1, -1, -1, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, -1, -1, -1, -1, 47, -1, 47, 47, 47, 47, 52, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47});
    NxS[52] = new Table(48, 75, -1, new sbyte[] {47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, -1, -1, -1, -1, -1, -1, -1, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, -1, -1, -1, -1, 47, -1, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47});
    NxS[53] = new Table(48, 75, -1, new sbyte[] {47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, -1, -1, -1, -1, -1, -1, -1, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, -1, -1, -1, -1, 47, -1, 47, 47, 47, 47, 47, 
        54, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47});
    NxS[54] = new Table(48, 75, -1, new sbyte[] {47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, -1, -1, -1, -1, -1, -1, -1, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, -1, -1, -1, -1, 47, -1, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47});
    NxS[55] = new Table(48, 75, -1, new sbyte[] {47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, -1, -1, -1, -1, -1, -1, -1, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, -1, -1, -1, -1, 47, -1, 56, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47});
    NxS[56] = new Table(48, 75, -1, new sbyte[] {47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, -1, -1, -1, -1, -1, -1, -1, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, -1, -1, -1, -1, 47, -1, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 57, 47, 47, 
        47, 47, 47, 47, 47});
    NxS[57] = new Table(48, 75, -1, new sbyte[] {47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, -1, -1, -1, -1, -1, -1, -1, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, -1, -1, -1, -1, 47, -1, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 58, 47, 47, 
        47, 47, 47, 47, 47});
    NxS[58] = new Table(48, 75, -1, new sbyte[] {47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, -1, -1, -1, -1, -1, -1, -1, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, -1, -1, -1, -1, 47, -1, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47});
    NxS[59] = new Table(0, 0, -1, null);
    NxS[60] = new Table(10, 87, 105, new sbyte[] {-1, 105, 105, 105, 105, 105, 
        105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 
        105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 
        105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 
        105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 
        105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 106, 105, 105, 105, 
        59});
    NxS[61] = new Table(48, 54, -1, new sbyte[] {66, 66, 66, 66, 66, 66, 
        66, 66, 66, 66, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 107, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 66, -1, -1, -1, -1, -1, 107});
    NxS[62] = new Table(46, 77, -1, new sbyte[] {61, -1, 62, 62, 62, 62, 
        62, 62, 62, 62, 62, 62, -1, -1, -1, -1, -1, -1, -1, 47, 47, 47, 
        47, 63, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, -1, -1, -1, -1, 62, -1, 47, 47, 47, 
        47, 63, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47});
    NxS[63] = new Table(43, 80, -1, new sbyte[] {64, -1, 64, -1, -1, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, -1, -1, -1, -1, -1, -1, -1, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, -1, -1, -1, -1, 47, -1, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47});
    NxS[64] = new Table(48, 48, -1, new sbyte[] {65, 65, 65, 65, 65, 65, 
        65, 65, 65, 65, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 65});
    NxS[65] = new Table(48, 48, -1, new sbyte[] {65, 65, 65, 65, 65, 65, 
        65, 65, 65, 65, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 65});
    NxS[66] = new Table(48, 54, -1, new sbyte[] {66, 66, 66, 66, 66, 66, 
        66, 66, 66, 66, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 107, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 66, -1, -1, -1, -1, -1, 107});
    NxS[67] = new Table(48, 48, -1, new sbyte[] {68, 68, 68, 68, 68, 68, 
        68, 68, 68, 68, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 68});
    NxS[68] = new Table(48, 48, -1, new sbyte[] {68, 68, 68, 68, 68, 68, 
        68, 68, 68, 68, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 68});
    NxS[69] = new Table(48, 75, -1, new sbyte[] {47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, -1, -1, -1, -1, -1, -1, -1, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, -1, -1, -1, -1, 47, -1, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 
        47, 47, 47, 47, 47});
    NxS[70] = new Table(0, 0, -1, null);
    NxS[71] = new Table(46, 56, -1, new sbyte[] {61, -1, 71, 71, 71, 71, 
        71, 71, 71, 71, 71, 71, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, 108, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 71, -1, -1, -1, -1, 
        -1, 108});
    NxS[72] = new Table(48, 48, -1, new sbyte[] {77, 77, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 77});
    NxS[73] = new Table(48, 55, -1, new sbyte[] {74, 74, 74, 74, 74, 74, 
        74, 74, 74, 74, -1, -1, -1, -1, -1, -1, -1, 74, 74, 74, 74, 74, 
        74, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 74, -1, 74, 74, 74, 74, 74, 
        74});
    NxS[74] = new Table(48, 55, -1, new sbyte[] {74, 74, 74, 74, 74, 74, 
        74, 74, 74, 74, -1, -1, -1, -1, -1, -1, -1, 74, 74, 74, 74, 74, 
        74, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 74, -1, 74, 74, 74, 74, 74, 
        74});
    NxS[75] = new Table(0, 0, -1, null);
    NxS[76] = new Table(0, 0, -1, null);
    NxS[77] = new Table(48, 48, -1, new sbyte[] {77, 77, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 77});
    NxS[78] = new Table(0, 0, -1, null);
    NxS[79] = new Table(0, 0, -1, null);
    NxS[80] = new Table(0, 0, -1, null);
    NxS[81] = new Table(0, 0, -1, null);
    NxS[82] = new Table(10, 83, 111, new sbyte[] {-1, 111, 111, 111, 111, 111, 
        111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 
        111, 111, 111, 111, 111, 111, 111, 81, 111, 111, 111, 111, 111, 111, 111, 111, 
        111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 
        111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 
        111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 112});
    NxS[83] = new Table(0, 0, -1, null);
    NxS[84] = new Table(0, 0, -1, null);
    NxS[85] = new Table(0, 0, -1, null);
    NxS[86] = new Table(48, 10, -1, new sbyte[] {88, 88, 88, 88, 88, 88, 
        88, 88, 88, 88});
    NxS[87] = new Table(0, 0, -1, null);
    NxS[88] = new Table(48, 10, -1, new sbyte[] {88, 88, 88, 88, 88, 88, 
        88, 88, 88, 88});
    NxS[89] = new Table(0, 0, -1, null);
    NxS[90] = new Table(10, 1, 90, new sbyte[] {-1});
    NxS[91] = new Table(0, 0, -1, null);
    NxS[92] = new Table(10, 83, 114, new sbyte[] {-1, 114, 114, 114, 114, 114, 
        114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 
        114, 114, 91, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 
        114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 
        114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 
        114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 115});
    NxS[93] = new Table(9, 114, 94, new sbyte[] {95, 96, 95, 95, 95, 94, 
        94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 
        94, 95, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 
        94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 
        94, 94, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 
        97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 94, 94, 94, 94, 
        97, 94, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 
        97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97});
    NxS[94] = new Table(0, 0, -1, null);
    NxS[95] = new Table(9, 24, -1, new sbyte[] {96, 96, 96, 96, 96, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, 96});
    NxS[96] = new Table(9, 24, -1, new sbyte[] {96, 96, 96, 96, 96, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, 96});
    NxS[97] = new Table(46, 77, -1, new sbyte[] {98, -1, 98, 98, 98, 98, 
        98, 98, 98, 98, 98, 98, -1, -1, -1, -1, -1, -1, -1, 98, 98, 98, 
        98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 
        98, 98, 98, 98, 98, 98, 98, -1, -1, -1, -1, 98, -1, 98, 98, 98, 
        98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 
        98, 98, 98, 98, 98, 98, 98});
    NxS[98] = new Table(46, 77, -1, new sbyte[] {98, -1, 98, 98, 98, 98, 
        98, 98, 98, 98, 98, 98, -1, -1, -1, -1, -1, -1, -1, 98, 98, 98, 
        98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 
        98, 98, 98, 98, 98, 98, 98, -1, -1, -1, -1, 98, -1, 98, 98, 98, 
        98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 
        98, 98, 98, 98, 98, 98, 98});
    NxS[99] = new Table(9, 114, 100, new sbyte[] {101, 102, 101, 101, 101, 100, 
        100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 
        100, 101, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 
        100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 
        100, 100, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 
        103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 100, 100, 100, 100, 
        103, 100, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 
        103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103});
    NxS[100] = new Table(0, 0, -1, null);
    NxS[101] = new Table(9, 24, -1, new sbyte[] {102, 102, 102, 102, 102, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, 102});
    NxS[102] = new Table(9, 24, -1, new sbyte[] {102, 102, 102, 102, 102, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, 102});
    NxS[103] = new Table(46, 77, -1, new sbyte[] {104, -1, 104, 104, 104, 104, 
        104, 104, 104, 104, 104, 104, -1, -1, -1, -1, -1, -1, -1, 104, 104, 104, 
        104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 
        104, 104, 104, 104, 104, 104, 104, -1, -1, -1, -1, 104, -1, 104, 104, 104, 
        104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 
        104, 104, 104, 104, 104, 104, 104});
    NxS[104] = new Table(46, 77, -1, new sbyte[] {104, -1, 104, 104, 104, 104, 
        104, 104, 104, 104, 104, 104, -1, -1, -1, -1, -1, -1, -1, 104, 104, 104, 
        104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 
        104, 104, 104, 104, 104, 104, 104, -1, -1, -1, -1, 104, -1, 104, 104, 104, 
        104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 
        104, 104, 104, 104, 104, 104, 104});
    NxS[105] = new Table(10, 87, 105, new sbyte[] {-1, 105, 105, 105, 105, 105, 
        105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 
        105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 
        105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 
        105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 
        105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 106, 105, 105, 105, 
        59});
    NxS[106] = new Table(10, 87, 105, new sbyte[] {-1, 105, 105, 105, 105, 105, 
        105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 
        105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 
        105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 
        105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 
        105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 106, 105, 105, 105, 
        60});
    NxS[107] = new Table(43, 3, -1, new sbyte[] {67, -1, 67});
    NxS[108] = new Table(43, 3, -1, new sbyte[] {64, -1, 64});
    NxS[109] = new Table(48, 48, -1, new sbyte[] {76, 76, 76, 76, 76, 76, 
        76, 76, 76, 76, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 76});
    NxS[110] = new Table(48, 48, -1, new sbyte[] {75, 75, 75, 75, 75, 75, 
        75, 75, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 75});
    NxS[111] = new Table(10, 83, 111, new sbyte[] {-1, 111, 111, 111, 111, 111, 
        111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 
        111, 111, 111, 111, 111, 111, 111, 81, 111, 111, 111, 111, 111, 111, 111, 111, 
        111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 
        111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 
        111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 112});
    NxS[112] = new Table(10, 83, 111, new sbyte[] {-1, 111, 111, 111, 111, 111, 
        111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 
        111, 111, 111, 111, 111, 111, 111, 82, 111, 111, 111, 111, 111, 111, 111, 111, 
        111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 
        111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 
        111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 112});
    NxS[113] = new Table(10, 1, 89, new sbyte[] {-1});
    NxS[114] = new Table(10, 83, 114, new sbyte[] {-1, 114, 114, 114, 114, 114, 
        114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 
        114, 114, 91, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 
        114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 
        114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 
        114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 115});
    NxS[115] = new Table(10, 83, 114, new sbyte[] {-1, 114, 114, 114, 114, 114, 
        114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 
        114, 114, 92, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 
        114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 
        114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 
        114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 115});
    }

int NextState(int qStat) {
    if (chr == ScanBuff.EOF)
        return (qStat <= maxAccept && qStat != currentStart ? currentStart : eofNum);
    else {
        int rslt;
        uint idx = (byte)(chr - NxS[qStat].min);
        if (idx >= (uint)NxS[qStat].rng) rslt = NxS[qStat].dflt;
        else rslt = NxS[qStat].nxt[idx];
        return (rslt == goStart ? currentStart : rslt);
    }
}

int NextState() {
    if (chr == ScanBuff.EOF)
        return (state <= maxAccept && state != currentStart ? currentStart : eofNum);
    else {
        int rslt;
        uint idx = (byte)(chr - NxS[state].min);
        if (idx >= (uint)NxS[state].rng) rslt = NxS[state].dflt;
        else rslt = NxS[state].nxt[idx];
        return (rslt == goStart ? currentStart : rslt);
    }
}
#endregion


#if BACKUP
        // ====================== Nested class ==========================

        internal class Context // class used for automaton backup.
        {
            public int bPos;
            public int cPos;
            public int state;
            public int cChr;
        }
#endif // BACKUP


        // ====================== Nested class ==========================

        public sealed class StringBuff : ScanBuff
        {
            string str;        // input buffer
            int bPos;          // current position in buffer
            int sLen;

            public StringBuff(string str)
            {
                this.str = str;
                this.sLen = str.Length;
            }

            public override int Read()
            {
                if (bPos < sLen) return str[bPos++];
                else if (bPos == sLen) { bPos++; return '\n'; }   // one strike, see newline
                else return EOF;                                  // two strikes and you're out!
            }

            public override int Peek()
            {
                if (bPos < sLen) return str[bPos];
                else return '\n';
            }

            public override string GetString(int beg, int end)
            {
                if (beg >= sLen || end <= beg) return ""; 
                return str.Substring(beg, end - beg);
            }

            public override int Pos
            {
                get { return bPos; }
                set { bPos = value; }
            }
        }

        // ====================== Nested class ==========================

        public sealed class StreamBuff : ScanBuff
        {
            BufferedStream bStrm;   // input buffer

            public StreamBuff(Stream str) { this.bStrm = new BufferedStream(str); }

            public override int Read()
            {
                int byt = bStrm.ReadByte();
                if (byt == -1) return EOF;
                else return byt;
            }

            public override int Peek()
            {
                int rslt = Read();
                bStrm.Seek(-1, SeekOrigin.Current);
                return rslt;
            }

            public override string GetString(int beg, int end)
            {
                if (end - beg <= 0) return "";
                long savePos = bStrm.Position;
                char[] arr = new char[end - beg];
                bStrm.Position = (long)beg;
                for (int i = 0; i < (end - beg); i++)
                    arr[i] = (char)Read();
                bStrm.Position = savePos;
                return new String(arr);
            }

            public override int Pos
            {
                get { return (int)bStrm.Position; }
                set { bStrm.Position = value; }
            }
        }

        // =================== End Nested classes =======================

        public Scanner(Stream file) {
            buffer = new StreamBuff(file);
            this.cPos = -1;
            this.chr = '\n'; // to initialize yyline, yycol and lineStart
            GetChr();
        }

        public Scanner() { }

        void GetChr()
        {
            if (chr == '\n') { lineStart = buffer.Pos; lNum++; }
            chr = buffer.Read(); cPos++;
        }

        void MarkToken()
        {
            tokPos = cPos;
            tokLin = lNum;
            tokCol = cPos - lineStart;
        }
        
        void MarkEnd()
        {
            tokTxt = null;
            tokEPos = cPos;
            tokELin = lNum;
            tokECol = cPos - lineStart;

        }

        // ================ StringBuffer Initialization ===================

        public override void SetSource(string source, int offset)
        {
            this.buffer = new StringBuff(source);
            this.buffer.Pos = offset;
            this.cPos = offset - 1;
            this.chr = '\n'; // to initialize yyline, yycol and lineStart
            GetChr();
        }
        
#if BABEL
        //
        //  Get the next token for Visual Studio
        //
        //  "state" is the inout mode variable that maintains scanner
        //  state between calls, using the EolState property. In principle,
        //  if the calls of EolState are costly set could be called once
        //  only per line, at the start; and get called only at the end
        //  of the line. This needs more infrastructure ...
        public override int GetNext(ref int state, out int start, out int end)
        {
            Tokens next = (Tokens)Scan();

            start = tokPos;
            end = tokEPos - 1; // end is the index of last char.

            return (int)next;
        }        
#endif // BABEL

        // ======== IScanner<> Implementation =========

        public override int yylex()
        {
            // parserMax is set by reflecting on the Tokens
            // enumeration.  If maxParseTokeen is defined
            // that is used, otherwise int.MaxValue is used.
            int next;
            do { next = Scan(); } while (next >= parserMax);
            return next;
        }
        
        int yyleng { get { return tokEPos - tokPos; } }
        int yypos { get { return tokPos; } }
        int yyline { get { return tokLin; } }
        int yycol { get { return tokCol; } }

        public string yytext
        {
            get 
            {
                if (tokTxt == null) 
                    tokTxt = buffer.GetString(tokPos, tokEPos);
                return tokTxt;
            }
        }

        void yyless(int n) { 
            int pos = tokPos + n;
            buffer.Pos = pos;
            cPos = pos - 1; 
            GetChr(); 
            MarkEnd(); 
        }

        // ============ methods available in actions ==============

        internal int YY_START {
            get { return currentScOrd; }
            set { currentScOrd = value; } 
        }
        
        internal void BEGIN(int next) {
            currentScOrd = next;
            currentStart = startState[next];
        }

        // ============== The main tokenizer code =================

        int Scan()
        {
                for (; ; )
                {
                    int next;              // next state to enter                   
#if BACKUP
                    bool inAccept = false; // inAccept ==> current state is an accept state
                    Result rslt = Result.noMatch;
                    // skip "idle" states
#if LEFTANCHORS
                    if (lineStart == cPos &&
                        NextState(anchorState[currentScOrd]) != currentStart)
                        state = anchorState[currentScOrd];
                    else {
                        state = currentStart;
                        while (NextState() == currentStart) {
                            GetChr();
                            if (lineStart == cPos &&
                                NextState(anchorState[currentScOrd]) != currentStart) {
                                state = anchorState[currentScOrd];
                                break;
                            }
                        }
                    }
#else // !LEFTANCHORS
                    state = currentStart;
                    while (NextState() == state) 
                        GetChr(); // skip "idle" transitions
#endif // LEFTANCHORS
                    MarkToken();
                    
                    while ((next = NextState()) != currentStart)
                        if (inAccept && next > maxAccept) // need to prepare backup data
                        {
                            Context ctx = new Context();
                            rslt = Recurse2(ctx, next);
                            if (rslt == Result.noMatch) RestoreStateAndPos(ctx);
                            // else if (rslt == Result.contextFound) RestorePos(ctx);
                            break;
                        }
                        else
                        {
                            state = next;
                            GetChr();
                            if (state <= maxAccept) inAccept = true;
                        }
#else // !BACKUP
#if LEFTANCHORS
                    if (lineStart == cPos &&
                        NextState(anchorState[currentScOrd]) != currentStart)
                        state = anchorState[currentScOrd];
                    else {
                        state = currentStart;
                        while (NextState() == currentStart) {
                            GetChr();
                            if (lineStart == cPos &&
                                NextState(anchorState[currentScOrd]) != currentStart) {
                                state = anchorState[currentScOrd];
                                break;
                            }
                        }
                    }
#else // !LEFTANCHORS
                    state = currentStart;
                    while (NextState() == state) 
                        GetChr(); // skip "idle" transitions
#endif // LEFTANCHORS
                    MarkToken();
                    // common code
                    while ((next = NextState()) != currentStart)
                    {
                        state = next;
                        GetChr();
                    }
#endif // BACKUP
                    if (state > maxAccept) 
                    {
                        state = currentStart;
                    }
                    else
                    {
                        MarkEnd();
#region ActionSwitch
    switch (state)
    {
        case eofNum:
            return (int)Tokens.EOF;
        case 1:
        case 2:
        case 5:
        case 6:
        case 93:
        case 95:
        case 96:
        case 99:
        case 101:
        case 102:
{    }
            break;
        case 3:
        case 7:
        case 11:
        case 12:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 34:
        case 36:
        case 45:
        case 46:
        case 70:
        case 78:
        case 79:
        case 80:
return (int)Tokens.Operator;
            break;
        case 4:
        case 10:
System.Console.Error.WriteLine("Error unknown'{0}'", yytext); return (int)Tokens.Unknown;
            break;
        case 8:
        case 13:
        case 38:
return (int)Tokens.Quote;
            break;
        case 9:
        case 90:
return (int)Tokens.Comment;
            break;
        case 14:
        case 15:
        case 33:
        case 35:
        case 42:
        case 43:
        case 44:
return (int)Tokens.Bracket;
            break;
        case 22:
        case 23:
        case 37:
        case 61:
        case 62:
        case 64:
        case 65:
        case 66:
        case 67:
        case 68:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
return (int)Tokens.Number;
            break;
        case 31:
        case 32:
        case 39:
        case 40:
        case 41:
        case 47:
        case 48:
        case 49:
        case 50:
        case 51:
        case 53:
        case 55:
        case 56:
        case 57:
        case 63:
        case 69:
return check_keyword(yytext);
            break;
        case 52:
BEGIN(CLASS); return (int)Tokens.Keyword;
            break;
        case 54:
BEGIN(DEF); return (int)Tokens.Keyword;
            break;
        case 58:
BEGIN(CLASS); return (int)Tokens.Keyword;
            break;
        case 59:
        case 60:
        case 81:
        case 82:
        case 91:
        case 92:
return (int)Tokens.String;
            break;
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
return (int)Tokens.Ident;
            break;
        case 94:
BEGIN(INITIAL);
            break;
        case 97:
        case 98:
BEGIN(INITIAL); return (int)Tokens.MethodName;
            break;
        case 100:
BEGIN(INITIAL);
            break;
        case 103:
        case 104:
BEGIN(INITIAL); return (int)Tokens.ClassName;
            break;
        default:
            break;
    }
#endregion
                    }
                }
        }

#if BACKUP
        Result Recurse2(Context ctx, int next)
        {
            // Assert: at entry "state" is an accept state AND
            //         NextState(state, chr) != currentStart AND
            //         NextState(state, chr) is not an accept state.
            //
            bool inAccept;
            SaveStateAndPos(ctx);
            state = next;
            if (state == eofNum) return Result.accept;
            GetChr();
            inAccept = false;

            while ((next = NextState()) != currentStart)
            {
                if (inAccept && next > maxAccept) // need to prepare backup data
                    SaveStateAndPos(ctx);
                state = next;
                if (state == eofNum) return Result.accept;
                GetChr(); 
                inAccept = (state <= maxAccept);
            }
            if (inAccept) return Result.accept; else return Result.noMatch;
        }

        void SaveStateAndPos(Context ctx)
        {
            ctx.bPos  = buffer.Pos;
            ctx.cPos  = cPos;
            ctx.state = state;
            ctx.cChr = chr;
        }

        void RestoreStateAndPos(Context ctx)
        {
            buffer.Pos = ctx.bPos;
            cPos = ctx.cPos;
            state = ctx.state;
            chr = ctx.cChr;
        }

        void RestorePos(Context ctx) { buffer.Pos = ctx.bPos; cPos = ctx.cPos; }
#endif // BACKUP

        // ============= End of the tokenizer code ================

#if STACK        
        internal void yy_clear_stack() { scStack.Clear(); }
        internal int yy_top_state() { return scStack.Peek(); }
        
        internal void yy_push_state(int state)
        {
            scStack.Push(currentScOrd);
            BEGIN(state);
        }
        
        internal void yy_pop_state()
        {
            // Protect against input errors that pop too far ...
            if (scStack.Count > 0) {
                int newSc = scStack.Pop();
                BEGIN(newSc);
            } // Otherwise leave stack unchanged.
        }
 #endif // STACK

        internal void ECHO() { Console.Out.Write(yytext); }
        
#region UserCodeSection

public static int check_keyword(string ident)
    {
        switch (ident)
        {
            case "if":        
            case "elsif":
            case "class":
            case "def":    
            case "do":    
            case "module":    
            case "yield":
            case "else":    
            case "unless":    
            case "ensure":    
            case "super":    
            case "then":    
            case "return":
            case "next":    
            case "while":    
            case "case":
            case "when":    
            case "break":    
            case "for":    
            case "in":    
            case "begin":
            case "rescue":    
            case "until":
            case "alias":
            case "undef":
            case "retry":
            case "redo":
            case "BEGIN":    
            case "end":    
            case "END":                
                return (int)Tokens.Keyword;

            case "and":    
            case "or":
            case "not":                
                return (int)Tokens.Operator;
        
            case "__FILE__":
            case "__LINE__":        
            case "self":                    
            case "false":    
            case "nil":    
            case "true":
                return (int)Tokens.Literal;                
                
            default:        
                return (int)Tokens.Ident;
        }
    }

#endregion
    } // end class Scanner
} // end namespace
